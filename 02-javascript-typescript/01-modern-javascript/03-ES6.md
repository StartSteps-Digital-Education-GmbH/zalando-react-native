# Guide 3: ES6+ Modern JavaScript Features

**Objective:** Learn the modern JavaScript features that you'll use daily in React and React Native development, including arrow functions, destructuring, ES modules, Promises, and `async`/`await`.

---

## 1. Arrow Functions

Arrow functions are a more concise way to write functions. They are especially useful for callbacks and methods where you want to preserve the lexical context of `this`.

### 1.1 Syntax Variants

```js
// Implicit return (single expression)
const add = (a, b) => a + b;

// Explicit return (multi-line)
const multiply = (a, b) => {
  const result = a * b;
  return result;
};

// One parameter (no need for parentheses)
const square = x => x * x;

// No parameters (empty parentheses)
const getRandom = () => Math.random();
```

### 1.2 Lexical `this`

Arrow functions **do not bind their own `this`**. Instead, they inherit it from the surrounding (lexical) context. This is very useful in React class components or event handlers.

```js
function Counter() {
  this.count = 0;

  // ❌ Incorrect: 'this' does not refer to Counter
  setInterval(function() {
    this.count++;
    console.log(this.count);
  }, 1000);

  // ✅ Correct: arrow function preserves 'this'
  setInterval(() => {
    this.count++;
    console.log(this.count);
  }, 1000);
}

new Counter();
```

> **✅ Good to Know**
>
> * Arrow functions **cannot** be used as constructors
> * No `arguments` object inside arrow functions
> * Great for concise callbacks (e.g., `.map()`, `.filter()`, event handlers)

---

## 2. Destructuring

Destructuring makes it easy to extract values from arrays or objects into variables—very handy when working with props, state, and APIs in React Native.

### 2.1 Array Destructuring

```js
const nums = [10, 20, 30, 40];

const [a, b] = nums;
console.log(a, b); // 10 20

const [first, , third] = nums;
console.log(first, third); // 10 30

const [head, ...tail] = nums;
console.log(head, tail); // 10 [20, 30, 40]
```

### 2.2 Object Destructuring

```js
const user = {
  id: 1,
  name: 'Alice',
  preferences: {
    theme: 'dark',
    language: 'en'
  }
};

const { id, name } = user;
console.log(id, name); // 1 "Alice"

const { preferences: { theme } } = user;
console.log(theme); // "dark"

const { age = 18 } = user;
console.log(age); // 18
```

> **✅ Tip in React**
>
> * Common in `props` and `useState` return values:
>
> ```js
> const [count, setCount] = useState(0);
> const { name, email } = props.user;
> ```

---

## 3. ES Modules

Modern JavaScript supports modular code using `import` and `export`. React Native fully supports ES Modules.

### 3.1 Named Exports

**math.js**

```js
export function add(a, b) {
  return a + b;
}

export const PI = 3.14;
```

**app.js**

```js
import { add, PI } from './math.js';

console.log(add(2, 3)); // 5
console.log(PI);        // 3.14
```

### 3.2 Default Exports

**logger.js**

```js
export default function log(msg) {
  console.log('[LOG]', msg);
}
```

**app.js**

```js
import log from './logger.js';

log('Hello, modules!'); // [LOG] Hello, modules!
```

### 3.3 Dynamic Imports (Bonus)

Useful for code-splitting or loading modules on demand.

```js
import('./heavyModule.js')
  .then(module => module.doHeavyWork())
  .catch(err => console.error(err));
```

> **✅ Tips**
>
> * Use named exports when exporting multiple things
> * Use default export when there's only one main thing
> * Avoid mixing default and named exports in the same file

---

## 4. Promises

Promises represent a value that may be available now, later, or never. They are the foundation of asynchronous programming in modern JS.

### 4.1 Creating a Promise

```js
function wait(ms) {
  return new Promise((resolve, reject) => {
    if (ms < 0) return reject(new Error('Invalid delay'));
    setTimeout(() => resolve(`Waited ${ms}ms`), ms);
  });
}
```

### 4.2 Using `.then()` / `.catch()`

```js
wait(1000)
  .then(msg => console.log('Done:', msg))
  .catch(err => console.error('Error:', err.message));
```

### 4.3 Chaining Promises

```js
wait(500)
  .then(msg => {
    console.log(msg);
    return wait(500);
  })
  .then(() => console.log('Another 500ms passed'))
  .catch(console.error);
```

> **✅ Good to Know**
>
> * Promises are useful for fetch calls, animations, and timers
> * Always handle errors with `.catch()` or try/catch

---

## 5. `async` / `await`

`async`/`await` lets you write asynchronous code as if it were synchronous. It’s built on top of Promises and is widely used in modern React codebases.

### 5.1 Basic Example

```js
async function runTasks() {
  try {
    const first = await wait(300);
    console.log(first);

    const second = await wait(300);
    console.log(second);
  } catch (err) {
    console.error('Caught error:', err.message);
  }
}

runTasks();
```

### 5.2 Run in Parallel with `Promise.all()`

```js
async function loadInParallel() {
  const [res1, res2] = await Promise.all([
    wait(300),
    wait(500)
  ]);
  console.log(res1, res2);
}

loadInParallel();
```

> **✅ Good to Know**
>
> * `await` can only be used inside `async` functions
> * `Promise.all()` is ideal for loading data in parallel
> * Combine `async` with `fetch()` to make API calls in React Native

---

## ✅ Summary

| Feature         | Usage in React Native                                |
| --------------- | ---------------------------------------------------- |
| Arrow Functions | Functional components, callbacks, event handlers     |
| Destructuring   | `props`, `state`, API responses                      |
| ES Modules      | Organize code into reusable files                    |
| Promises        | `fetch()` API, async storage, network calls          |
| `async`/`await` | Clean and readable async logic in effects or actions |

---
