# Guide 4: React Strict DOM (RSD)
React Strict DOM (RSD) provides a unified, cross-platform API for building UIs with strict HTML elements and strict CSS styling that compile to native components on mobile and optimized CSS on web. By constraining the available HTML, CSS, and Web APIs to a well-defined subset, RSD ensures type safety, design-system alignment, and ease of migration from web to native. Under the hood, you use the same JSX syntax and React paradigms you already know—components, props, state, and hooks—but render via RSD’s `html` and `css` APIs rather than raw DOM or React Native primitives.

---

## ## Introduction to React Strict DOM

React Strict DOM defines a subset of React DOM and Web APIs for cross-platform rendering, letting you write “web-first” React that also runs natively.

### Markup with Strict HTML  
Instead of `<div>` or `<button>` you import from RSD’s `html` namespace:

```jsx
import { html } from 'react-strict-dom';

function MyPage() {
  return (
    <html.main>
      <html.div>
        <html.label htmlFor="name">Name</html.label>
        <html.input id="name" />
      </html.div>
    </html.main>
  );
}
```
> Here every element (`html.main`, `html.div`, etc.) is a type-safe component that excludes legacy or unsupported attributes.

---

## ## Styling with Strict CSS

RSD’s CSS API (`css.create`) lets you author styles in JS objects that map to atomic CSS (web) or inline styles (native):

```jsx
import { css, html } from 'react-strict-dom';

const styles = css.create({
  button: {
    backgroundColor: {
      default: 'white',
      ':hover': 'lightgray'
    },
    padding: 10
  }
});

function MyButton(props) {
  return (
    <html.button {...props} style={styles.button}>
      A cross-platform button
    </html.button>
  );
}
```
> Styles defined via `css.create` are automatically extracted to optimized atomic CSS on web, and applied via platform-native styles on mobile.

---

## ## Incremental Cross-Platform Adoption

RSD supports gradual migration by letting you use platform-specific files:

```jsx
// Button.web.js
import { html, css } from 'react-strict-dom';
const styles = css.create({ button: { paddingBlock: '0.5rem' } });
export function Button(props) {
  return <html.button {...props} style={styles.button} />;
}

// Button.native.js
import { View, StyleSheet } from 'react-native';
const styles = StyleSheet.create({ button: { paddingVertical: 10 } });
export function Button(props) {
  return <View {...props} style={styles.button} />;
}
```
> By opting into `.web.js` or `.native.js`, you can hook into host-platform APIs where needed while still using RSD components elsewhere.

---

## ## Component Composition & Code Organization

RSD components interoperate seamlessly with your own presentational and container components:

```jsx
// In src/components/Card.tsx
import { html, css } from 'react-strict-dom';

const styles = css.create({
  container: {
    border: { default: '1px solid gray' },
    padding: '1rem',
    borderRadius: '0.5rem'
  }
});

export function Card({ children }) {
  return <html.div style={styles.container}>{children}</html.div>;
}
```
> Compose RSD’s `html.div` with your own component hierarchy; style encapsulation is guaranteed by the CSS API.

---

## ## Handling Events

Use React’s event system on strict HTML elements:

```jsx
import { html } from 'react-strict-dom';

function Clicker() {
  function handleClick(e) {
    // `e` is a React SyntheticEvent
    console.log('Clicked!');
  }

  return (
    <html.button onClick={handleClick}>
      Click me
    </html.button>
  );
}
```
> RSD’s `html.button` forwards its `onClick` prop to the underlying platform element—no change from standard React event logic.

---

## ## Conditional Rendering

Since RSD elements behave like standard React components, you can apply familiar patterns:

```jsx
function StatusMessage({ status }) {
  return status === 'loading' ? (
    <html.div>Loading…</html.div>
  ) : status === 'error' ? (
    <html.div>Error occurred</html.div>
  ) : (
    <html.div>Data loaded</html.div>
  );
}
```
> Use ternaries, logical AND, or early returns exactly as you would with React DOM or React Native, but with type-safe RSD elements.

