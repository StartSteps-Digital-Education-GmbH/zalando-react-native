# Guide 3: ES6+ Modern JavaScript Features

**Objective:** Learn the syntax and semantics of arrow functions, destructuring, ES modules, Promises, and `async`/`await`. These features are essential for writing clean, concise code in React and React Native.

---

## 1. Arrow Functions

### 1.1 Syntax Variants

```js
// 1.1.1 Single expression, implicit return
const add = (a, b) => a + b;

// 1.1.2 Multiple statements, explicit return
const multiply = (a, b) => {
  const result = a * b;
  return result;
};

// 1.1.3 Single parameter: parentheses optional
const square = x => x * x;

// 1.1.4 No parameters: empty parentheses
const getRandom = () => Math.random();
```

### 1.2 Lexical `this`

Arrow functions do **not** bind their own `this`; they inherit from the enclosing scope.

```js
function Counter() {
  this.count = 0;

  // Traditional function: `this` changes based on call site
  setInterval(function() {
    this.count++;             // ❌ `this` is `window` or undefined
    console.log(this.count);
  }, 1000);

  // Arrow function: `this` lexically inherited
  setInterval(() => {
    this.count++;             // ✔️ `this` is the Counter instance
    console.log(this.count);
  }, 1000);
}

new Counter();
```
> **Key Points**  
> - No own `this`, arguments, or `new.target`   
> - Cannot be used as constructors (no `new`)  

---

## 2. Destructuring

### 2.1 Array Destructuring

```js
const nums = [10, 20, 30, 40];

// Basic unpack
const [a, b] = nums;
console.log(a, b); // 10 20

// Skip elements
const [first, , third] = nums;
console.log(first, third); // 10 30

// Rest element
const [head, ...tail] = nums;
console.log(head, tail);   // 10 [20,30,40]
```

### 2.2 Object Destructuring

```js
const user = {
  id: 1,
  name: 'Alice',
  preferences: {
    theme: 'dark',
    language: 'en'
  }
};

// Basic unpack
const { id, name } = user;
console.log(id, name); // 1 "Alice"

// Nested unpack
const { preferences: { theme } } = user;
console.log(theme);    // "dark"

// Default values
const { age = 18 } = user;
console.log(age);      // 18
```
> **Key Points**  
> - Use `[ ]` for arrays, `{ }` for objects   

---

## 3. ES Modules

### 3.1 Named Exports & Imports

**math.js**  
```js
export function add(a, b) {
  return a + b;
}

export const PI = 3.14159;
```

**app.js**  
```js
import { add, PI } from './math.js';

console.log(add(2, 3)); // 5
console.log(PI);        // 3.14159
```

### 3.2 Default Exports

**logger.js**  
```js
export default function log(msg) {
  console.log('[LOG]', msg);
}
```

**app.js**  
```js
import log from './logger.js';

log('Hello, modules!'); // [LOG] Hello, modules!
```

### 3.3 Dynamic Imports (Bonus)

```js
// Load module on demand
button.addEventListener('click', () => {
  import('./heavyModule.js')
    .then(module => module.doHeavyWork())
    .catch(err => console.error(err));
});
```
> **Key Points**  
> - Static `import`/`export` at top-level   
> - Dynamic `import()` returns a Promise   

---

## 4. Promises

### 4.1 Creating a Promise

```js
function wait(ms) {
  return new Promise(function(resolve, reject) {
    if (ms < 0) {
      return reject(new Error('ms must be non-negative'));
    }
    setTimeout(function() {
      resolve(`Waited ${ms}ms`);
    }, ms);
  });
}
```

### 4.2 Consuming with `.then()` / `.catch()`

```js
wait(1000)
  .then(function(message) {
    console.log('Success:', message);
  })
  .catch(function(error) {
    console.error('Error:', error.message);
  });
```

### 4.3 Chaining

```js
wait(500)
  .then(msg => {
    console.log(msg);
    return wait(500);
  })
  .then(() => console.log('Another 500ms'))
  .catch(err => console.error(err));
```
> **Key Points**  
> - Promises represent eventual results   
> - Always handle rejections with `.catch()`   

---

## 5. `async` / `await`

### 5.1 Syntactic Sugar over Promises

```js
async function runTasks() {
  try {
    const first = await wait(300);
    console.log(first);        // "Waited 300ms"
    const second = await wait(300);
    console.log(second);       // "Waited 300ms"
  } catch (err) {
    console.error('Caught:', err);
  }
}

runTasks();
```

### 5.2 Parallel Execution

```js
async function parallelTasks() {
  const p1 = wait(300);
  const p2 = wait(500);
  const results = await Promise.all([p1, p2]);
  console.log(results);       // ["Waited 300ms","Waited 500ms"]
}

parallelTasks();
```
> **Key Points**  
> - `async` functions always return a Promise   
> - Use `Promise.all()` to run in parallel   
